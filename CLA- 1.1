Note:Minor ADC issue on one pin in MSP430G2553 spotted.
CLA code working. One voltage divider factor incorporated.
Testing not done. Testing resumes from 11th Feb due to T1.

#include <msp430.h>
#define TIMERCOUNT 1284
#define DEADTIME 0.2*TA2CCR0
#define CV 14
#define UPPERLIMIT   0.8
#define LOWERLIMIT   0.2
#define x 0.01
#define initduty 0.5 * TA2CCR0
float temp1;
float temp2;
float dutyactual = 0;
float duty;
float a;
int i = 100;
float Vin;
float Vout;
float V2 = 0;
int count=0;
float t;
// factor for A-B is 5.2
//factor for C and D is 46.5
void SetVcoreUp (unsigned int level)
 {
    // Subroutine to change core voltage
       // Open PMM registers for write
       PMMCTL0_H = PMMPW_H;
       // Set SVS/SVM high side new level
       SVSMHCTL = SVSHE + SVSHRVL0 * level + SVMHE + SVSMHRRL0 * level;
       // Set SVM low side to new level
       SVSMLCTL = SVSLE + SVMLE + SVSMLRRL0 * level;
       // Wait till SVM is settled
       while ((PMMIFG & SVSMLDLYIFG) == 0);
       // Clear already set flags
       PMMIFG &= ~(SVMLVLRIFG + SVMLIFG);
       // Set VCore to new level
       PMMCTL0_L = PMMCOREV0 * level;
       // Wait till new level reached
       if ((PMMIFG & SVMLIFG))
         while ((PMMIFG & SVMLVLRIFG) == 0);
       // Set SVS/SVM low side to new level
       SVSMLCTL = SVSLE + SVSLRVL0 * level + SVMLE + SVSMLRRL0 * level;
       // Lock PMM registers for write access
       PMMCTL0_H = 0x00;
}
void readADC()
{
    i = 1000;
    ADC12CTL0 |= ADC12SC;                   // Start conversion
    __delay_cycles(10000);

    Vin = (ADC12MEM0*(0.00061) * 5.20);   //For resistors A and B.
    Vout = (ADC12MEM1*(0.00061)/0.0215);   //For resistors C and D.


    if(Vin > 14.7)                         //buck mode
    {
        t = TIMERCOUNT * CV/Vin;

    }
    if(Vin < 14 && Vin > 0.7)          //for boost mode
    {
        t = TIMERCOUNT - (TIMERCOUNT * Vin)/CV;

    }
    TA2CCR1 = t;

}

void main(void)
                                                                                                                                                                                                    {
    WDTCTL = WDTPW | WDTHOLD;  //watchdog timer
    P2DIR |= BIT5 + BIT4;       //set output direction
    P2SEL |= BIT5 + BIT4;
    P6SEL |= BIT0 + BIT1;

    TA2CCR0 = TIMERCOUNT;                 //time period
    TA2CCR1 = TIMERCOUNT/2;
    duty = TA2CCR1/TA2CCR0;
    TA2CCTL1 = OUTMOD_6;            //set output mode
    TA2CCTL2 = OUTMOD_2;
    TA2CTL = TASSEL_2 + MC_3;    //clk setup in up down mode.

    REFCTL0 &= ~REFMSTR;                      // Reset REFMSTR to hand over control to
                                                          // ADC12_A ref control registers
    ADC12CTL0 = ADC12ON+ADC12MSC+ADC12SHT0_0;                                         // Turn on ADC12, set sampling time
    ADC12CTL1 = ADC12SHP+ADC12CONSEQ_1 + ADC12SSEL_0;                                        // Use sampling timer, single sequence
    ADC12CTL2 = ADC12RES_2;
    ADC12MCTL0 = ADC12INCH_0;                 // ref+=AVcc, channel = A0
    ADC12MCTL1 = ADC12INCH_1 + ADC12EOS;      // ref+=AVcc, channel = A1
    ADC12IE = 0x08;                           // Enable ADC12IFG.3
    ADC12CTL0 |= ADC12ENC;                    // Enable conversions

    for (i = 0 ; i < 50; i++);                  // Delay for reference start-up

    SetVcoreUp (0x01);
    SetVcoreUp (0x02);
    SetVcoreUp (0x03);

    UCSCTL0 = DCO4 + DCO3 + DCO2 + 0x00FF;   // Set lowest possible DCOx DCO4 + DCO3 + DCO2 + DCO1 + DCO0 +, MODx
    UCSCTL1 = DCORSEL_7 ;                    // Select DCO range 60MHz-135MHz operation
    UCSCTL2 = FLLD_0 + 4119;


    readADC();
    readADC();
    //while(!(ADC12IFG));

    __bis_SR_register( GIE);       // Enter LPM0, enable interrupts
    __no_operation();                         // For debugger
    duty = t/TIMERCOUNT;
    for(;;) {

        while(i != 0)
        {
            if(Vout < 14) {

                    if(duty >= UPPERLIMIT) {
                        TA2CCR1 = UPPERLIMIT;
                        TA2CCR2 = TA2CCR1 - DEADTIME;
                    }

                    else if(duty <= UPPERLIMIT) {
                        duty = duty + x;
                        TA2CCR1 = duty*TA2CCR0;
                        TA2CCR2 = TA2CCR1 - DEADTIME;
                    //__delay_cycles(1000000);

                    temp1 = TA2CCR1;
                    temp2 = TA2CCR0;

                    }
                }
                if(Vout > 14) {
                    temp1 = TA2CCR1;
                    if(duty <= LOWERLIMIT) {
                        TA2CCR1 = LOWERLIMIT;
                        TA2CCR2 = TA2CCR1 - DEADTIME;
                        temp1 = TA2CCR1;
                    }
                    else if(duty >= LOWERLIMIT) {
                        duty = duty - x;
                        TA2CCR1 = duty*TA2CCR0;
                        TA2CCR2 = TA2CCR1 - DEADTIME;
                        //__delay_cycles(1000000);
                    }
                    temp1 = TA2CCR1;
                    temp2 = TA2CCR0;

                }
                dutyactual = temp1/temp2;
                i--;
        }
                readADC();
                readADC();

    }
}
